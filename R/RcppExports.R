# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' gdp penalty function
#'
#' This function define the gdp penalty. The
#' formula is \code{gdp(x) =lambda*log(1+x/gamma)}.
#' Details can be found in \url{https://arxiv.org/abs/1807.04982}.
#'
#' @param x a non-negative numeric vector
#' @param gamma hyper-tuning parameter
#' @param lambda tuning parameter
#'
#' @return the value of gdp penalty
#'
#' @examples
#' \dontrun{gdp(0:9,gamma=1,lambda=5)}
NULL

#' Super gradient of gdp penalty function
#'
#' This function define the super gradient of the gdp penalty.
#' The formula is \code{gdp_sg(x) = lambda/(gamma+x)}.
#' Details can be found in \url{https://arxiv.org/abs/1807.04982}
#'
#' @inheritParams gdp
#'
#' @return the super-gradient of the gdp penalty function
#'
#' @examples
#' \dontrun{gdp_sg(0:9,gamma=1,lambda=5)}
NULL

#' Lq penalty function
#'
#' This function define the Lq penalty. The
#' formula is \code{Lq(x) =lambda*x^q}.
#' Details can be found in \url{https://arxiv.org/abs/1807.04982}
#'
#' @inheritParams gdp
#'
#' @return the value of the Lq penalty
#'
#' @examples
#' \dontrun{lq(0:9,gamma=0.5,lambda=5)}
NULL

#' Super gradient of the Lq penalty function
#'
#' This function define the super gradient of the Lq penalty.
#' The formula is \code{lq_sg(x) = lambda * q * x^(p-1)}.
#' Details can be found in \url{https://arxiv.org/abs/1807.04982}
#'
#' @inheritParams lq
#'
#' @return the super-gradient of the Lq penalty function
#'
#' @examples
#' \dontrun{
#' lq_sg(0:9,gamma=1,lambda=5)
#' lq_sg(0:9,gamma=0.5,lambda=5)
#' }
NULL

#' SCAD penalty function
#'
#' This function define the SCAD penalty.
#' Details can be found in \url{https://arxiv.org/abs/1807.04982}
#'
#' @inheritParams gdp
#'
#' @return the value of SCAD penalty
#'
#' @examples
#' \dontrun{scad(0:9,gamma=3.7,lambda=3)}
NULL

#' Super gradient for the SCAD penalty function
#'
#' This function define the supergradient of the SCAD penalty.
#' Details can be found in \url{https://arxiv.org/abs/1807.04982}
#'
#' @inheritParams scad
#'
#' @return the super gradient of the SCAD penalty
#'
#' @examples
#' \dontrun{scad_sg(0:9,gamma=3.7,lambda=3)}
NULL

#' The log-partation function of Bernoulli distribution
#'
#' This function define the log-partation function
#' of Bernoulli distribution. The formula is
#' \code{log_part_B(Theta) = log(1+exp(Theta))}.
#' Details can be found in \url{https://arxiv.org/abs/1902.06241}.
#'
#' @param Theta a matrix of natural parameter
#'
#' @return The value of the corresponding log-partation function
#'
#' @examples
#' \dontrun{log_part_B(matrix(0:9,2,5))}
NULL

#' The first order gradient of log-partation function of Bernoulli distribution
#'
#' This function define first order gradient of the log-partation function
#' of Bernoulli distribution. The formula is
#' \code{log_part_B_g(Theta) = exp(Theta)/(1+exp(Theta))}.
#' Details can be found in \url{https://arxiv.org/abs/1902.06241}.
#'
#' @inheritParams log_part_B
#'
#' @return value of the first order gradient
#'
#' @examples
#' \dontrun{log_part_B_g(matrix(0:9,2,5))}
NULL

#' The log-partation function of Gaussian distribution
#'
#' This function define the log-partation function
#' of Gaussian distribution. The formula is
#' \code{log_part_G(Theta) = 0.5*(Theta^2)}.
#' Details can be found in \url{https://arxiv.org/abs/1902.06241}.
#'
#' @inheritParams log_part_B
#'
#' @return the value of the corresponding log-partation function
#'
#' @examples
#' \dontrun{log_part_G(matrix(0:9,2,5))}
NULL

#' The first order gradient of log-partation function of Gaussian distribution
#'
#' This function define first order gradient of the log-partation function
#' of Gaussian distribution. The formula is
#' \code{log_part_G_g(Theta) = Theta}.
#' Details can be found in \url{https://arxiv.org/abs/1902.06241}.
#'
#' @inheritParams log_part_G
#'
#' @return value of the first order gradient
#'
#' @examples
#' \dontrun{log_part_G_g(matrix(0:9,2,5))}
NULL

#' The log-partation function of Possion distribution
#'
#' This function define the log-partation function
#' of Possion distribution. The formula is
#' \code{log_part_G(Theta) = exp(Theta)}.
#' Details can be found in \url{https://arxiv.org/abs/1902.06241}.
#'
#' @inheritParams log_part_B
#'
#' @return the value of the corresponding log-partation function
#'
#' @examples
#' \dontrun{log_part_P(matrix(0:9,2,5))}
NULL

#' The first order gradient of log-partation function of Possion distribution
#'
#' This function define first order gradient of the log-partation function
#' of Possion distribution. The formula is
#' \code{log_part_P_g(Theta) = exp(Theta)}.
#' Details can be found in \url{https://arxiv.org/abs/1902.06241}.
#'
#' @inheritParams log_part_P
#'
#' @return value of the first order gradient
#'
#' @examples
#' \dontrun{log_part_P_g(matrix(0:9,2,5))}
NULL

#' Updating loading matrix B when conave L2 norm penalty is used
#'
#' This is an intermediate step of the algorithm for fitting pESCA model. The
#' details of this function can be found in ref thesis.
#'
#' @param JHk An output of the majorizaiotn step
#' @param A The score matrix A during k-th iteration
#' @param B0 The loading matrix B during the previous iteration
#' @param Sigmas0 The group length during the previous iteration
#' @param d A numeric vector contains the numbers of variables in different data sets
#' @param fun_concave A string indicates the used concave function
#' @param alphas The dispersion parameters of exponential dispersion families
#' @param rhos An output of the majorizaiotn step
#' @param lambdas A numeric vector indicates the values of tuning parameters for
#' each data set.
#' @param gamma The hyper-parameter of the concave penalty
#'
#' @return This function returns the updated loading matrix B.
#'
#' @examples
#' \dontrun{
#' B <- update_B_L2(JHk,A,B0,Sigmas0,d,
#'                    fun_concave,alphas,rhos,lambdas,gamma)
#' }
NULL

#' Group-wise conave L2 norm penalty
#'
#' This is an intermediate step of the algorithm for fitting pESCA model. The
#' details of this function can be found in ref thesis.
#'
#' @param B The loading matrix for the ith data set
#' @param Sigmas The matrix to hold the group characters
#' @param d the vector contains the number of variables in each data set
#' @param fun_concave A string indicates the used concave function
#' @param gamma The hyper-parameter of the concave penalty
#'
#' @return This function returns the value of the
#' group-wise conave L2 norm penalty for the pESCA model
#'
#' @examples
#' \dontrun{
#' concave_L2(B_i, fun_concave, gamma, R)
#' }
NULL

#' Updating loading matrix B with conave L1 norm penalty
#'
#' This is an intermediate step of the algorithm for fitting pESCA model. The
#' details of this function can be found in ref thesis.
#'
#' @inheritParams update_B_L2
#'
#' @return This function returns the updated loading matrix B.
#'
#' @examples
#' \dontrun{
#' B <- update_B_L1(JHk,A,B0,Sigmas0,d,
#'                    fun_concave,alphas,rhos,lambdas,gamma)
#' }
NULL

#' Group-wise conave L1 norm penalty
#'
#' This is an intermediate step of the algorithm for fitting pESCA model. The
#' details of this function can be found in ref thesis.
#'
#' @inheritParams penalty_concave_L2
#'
#' @return This function returns the value of the
#' group-wise conave L1 norm penalty for the pESCA model
#'
#' @examples
#' \dontrun{
#' penalty_concave_L1(B_i, fun_concave, gamma, R)
#' }
NULL

#' Updating loading matrix B with the composite concave penalty
#'
#' This is an intermediate step of the algorithm for fitting pESCA model. The
#' details of this function can be found in ref thesis.
#'
#' @inheritParams update_B_L2
#'
#' @return This function returns the updated loading matrix B.
#'
#' @examples
#' \dontrun{
#' B <- update_B_composite(JHk,A,B0,Sigmas0,d,
#'                    fun_concave,alphas,rhos,lambdas,gamma)
#' }
NULL

#' Composition of group-wise and element-wise conave penalty
#'
#' This is an intermediate step of the algorithm for fitting pESCA model. The
#' details of this function can be found in ref thesis.
#'
#' @inheritParams penalty_concave_L2
#'
#' @return This function returns the value of the composition
#' of group-wise and element-wise conave penalty for the pESCA model
#'
#' @examples
#' \dontrun{
#' concave_composite(B_i, fun_concave, gamma, R)
#' }
NULL

#' Updating loading matrix B with the element-wise concave penalty
#'
#' This is an intermediate step of the algorithm for fitting pESCA model. The
#' details of this function can be found in ref thesis.
#'
#' @inheritParams update_B_L2
#'
#' @return This function returns the updated loading matrix B.
#'
#' @examples
#' \dontrun{
#' B <- update_B_element(JHk,A,B0,Sigmas0,d,
#'                    fun_concave,alphas,rhos,lambdas,gamma)
#' }
NULL

#' Element-wise conave penalty
#'
#' This is an intermediate step of the algorithm for fitting pESCA model. The
#' details of this function can be found in ref thesis.
#'
#' @inheritParams penalty_concave_L2
#'
#' @return This function returns the value of the
#' element-wise conave penalty for the pESCA model
#'
#' @examples
#' \dontrun{
#' penalty_concave_element(B_i, fun_concave, gamma, R)
#' }
NULL

#' C++ implementation of penalized exponential family simultaneous component analysis (pESCA) model
#'
#' This is the main function for construncting a pESCA model on multiple data
#' sets. The potential different data types in these data sets are tackled by
#' the assumption of exponential family distribution. Gaussian for quantitative
#' data, Bernoulli for binary data and Poisson for count data. Although the option
#' for count data using Poisson distribution is included in the algorithm, we recommend
#' to do variance stabilizing transformation on the count data, such as Next-Gen
#' sequencing data, and then use the transformed data as quantitative data sets. The
#' details of the developed algorithm can be found in \url{https://arxiv.org/abs/1902.06241}.
#' 
#' @inheritParams pESCA
#' 
#' @param X the matrix to hold all the data sets
#' @param d the vector to indicate the number of variables in each data set
#'
#' @import RSpectra
#'
#' @examples
#' \dontrun{
#' # Suppose we have three data sets X1, X2, X3
#' # They are quantitative, quantitative and binary matrices
#' pESCA_C(X = X, d = d,
#'               dataTypes = c("G", "G", "B"),
#'               lambdas = c(20, 20, 10),
#'               penalty = 'L2',
#'               fun_concave = 'gdp',
#'               opts = list())
#' }
#'
#' @export
pESCA_C <- function(X, d, dataTypes, lambdas, penalty, fun_concave, opts) {
    .Call('_RpESCA2_pESCA_C', PACKAGE = 'RpESCA2', X, d, dataTypes, lambdas, penalty, fun_concave, opts)
}

#' A svd algorithm with the option for missing values.
#'
#' This function implemented a MM algorithm to fit a svd on a quantitaive data
#' set with missing values. The details of this function can be found
#' in \url{https://arxiv.org/abs/1902.06241}.
#'
#' @param X a quantitative data set
#' @param R the number of PCs
#' @param opts a list contains the setting for the algorithm. \itemize{
#' \item tol_obj: tolerance for relative change of hist_obj, default:1E-6;
#' \item maxit: max number of iterations, default: 1000;
#' }
#'
#' @return This function returns a list contains \itemize{
#' \item U: the left singular vectors
#' \item S: a column vector contains the singular values
#' \item V: the right singular vectors
#' \item iter: the number of iterations used
#' \item diagnose: records hist_obj and rel_obj
#' }
#'
#' @import RSpectra
#' 
#' @examples
#' \dontrun{svd_mis(X,R=3,opts=list())}
#'
#' @export
svd_mis <- function(X, R, opts) {
    .Call('_RpESCA2_svd_mis', PACKAGE = 'RpESCA2', X, R, opts)
}

#' Model selection of a svd model using missing value based CV error.
#' 
#' This function implemented a missing value based CV model selection approach.
#' First, ratio_mis percent elements are randomly selected as missing values. After
#' that a EM-SVD model is constructed to estimate the prediction error.
#' The details of this function can be found in \url{https://arxiv.org/abs/1902.06241}.
#'
#' @inheritParams alpha_estimation
#' @param ratio_mis the propotion of missing values
#'
#' @return This function returns a matrix contains the K-fold 
#' cross validation errors and the number of PCs used for 
#' model selection.
#'
#' @examples
#' \dontrun{svd_CV(X,K=3,Rs=1:15,ratio_mis=0.1,opts=list())}
#'
#' @export
svd_CV <- function(X, K, Rs, ratio_mis, opts) {
    .Call('_RpESCA2_svd_CV', PACKAGE = 'RpESCA2', X, K, Rs, ratio_mis, opts)
}

